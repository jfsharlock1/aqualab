<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AquaLab — Calibration TEST Lab</title>
  <link rel="stylesheet" href="./pooltest.css" />
</head>
<body>
  <header class="pt-header">
    <div class="logo"></div>
    <div class="titling">
      <h1>Calibration Lab</h1>
      <div class="muted">Use an unused strip to calibrate lighting and explain repeatability.</div>
    </div>
    <nav class="pt-nav">
      <a href="./index.html">Back to Scanner</a>
    </nav>
  </header>

  <main class="container">
    <section class="card">
      <h2>Calibration Lab</h2>
      <p class="muted">
        Use an <strong>unused (dry) strip</strong> so the pads represent baseline colors.
        This helps demonstrate how we correct lighting differences and reduce measurement noise.
      </p>

      <div class="row row-wrap" style="margin:10px 0;">
        <button type="button" class="btn" id="calTake">Take Photo</button>
        <button type="button" class="btn" id="calChoose">Choose Photo</button>
        <input id="calTakeInput" type="file" accept="image/*" capture="environment" hidden>
        <input id="calFileInput" type="file" accept="image/*" hidden>
        <button type="button" class="btn-ghost" id="calReset">Reset Calibration</button>
      </div>

      <div class="scan-view" style="max-width:520px;">
        <canvas id="calCanvas" style="width:100%; height:auto; display:block;"></canvas>
        <div class="scan-frame">
          <div class="scan-frame-label">Tap strip body to set white balance</div>
        </div>
      </div>

      <p class="muted" id="calStatus" style="margin-top:8px;"></p>

      <hr style="border:0; border-top:1px solid rgba(148,163,184,0.25); margin:14px 0;">

      <h3>1) White Balance (Unused Strip Body)</h3>
      <p class="muted hint">
        Click a white/gray area of the strip body (not a colored pad). This stores white-balance multipliers on this device.
      </p>
      <div class="row row-wrap">
        <div class="tag" id="wbTag">WB: not set</div>
      </div>

      <h3 style="margin-top:14px;">2) Pad Offsets (Optional)</h3>
      <p class="muted hint">
        If your lighting rig consistently biases a reading, you can apply a small offset.
        These offsets are stored on this device and applied during scanning.
      </p>

      <div class="history-grid" style="grid-template-columns:repeat(2,minmax(0,1fr));">
        <div class="card" style="padding:12px;">
          <h3>pH offset</h3>
          <label class="muted" style="font-size:12px;">Add/Subtract to pH result</label>
          <input id="offPh" type="number" step="0.05" value="0">
        </div>
        <div class="card" style="padding:12px;">
          <h3>Alkalinity offset</h3>
          <label class="muted" style="font-size:12px;">Add/Subtract ppm</label>
          <input id="offAlk" type="number" step="10" value="0">
        </div>
        <div class="card" style="padding:12px;">
          <h3>CYA offset</h3>
          <label class="muted" style="font-size:12px;">Add/Subtract ppm</label>
          <input id="offCya" type="number" step="10" value="0">
        </div>
        <div class="card" style="padding:12px;">
          <h3>Hardness offset</h3>
          <label class="muted" style="font-size:12px;">Add/Subtract ppm</label>
          <input id="offHard" type="number" step="25" value="0">
        </div>
      </div>

      <div class="row row-wrap" style="margin-top:10px;">
        <button type="button" class="btn" id="saveCal">Save Calibration</button>
        <div class="muted" id="calSavedHint"></div>
      </div>

      <hr style="border:0; border-top:1px solid rgba(148,163,184,0.25); margin:14px 0;">

      <h3>3) Add Past Data Points (Manual)</h3>
      <p class="muted hint">
        Add older readings to the same on-device history used by the Scanner graphs.
        After adding, go back to the Scanner to see the charts update.
      </p>

      <div class="history-grid" style="grid-template-columns:repeat(2,minmax(0,1fr));">
        <div class="card" style="padding:12px;">
          <h3>Date / time</h3>
          <label class="muted" style="font-size:12px;">Local time (optional)</label>
          <input id="mTime" type="datetime-local">
          <small class="muted">Leave blank to use “now”.</small>
        </div>

        <div class="card" style="padding:12px;">
          <h3>Gallons</h3>
          <label class="muted" style="font-size:12px;">Optional</label>
          <input id="mGallons" type="number" step="50" min="0" placeholder="e.g., 15000">
        </div>

        <div class="card" style="padding:12px;">
          <h3>pH</h3>
          <input id="mPh" type="number" step="0.01" min="0" placeholder="e.g., 7.4">
        </div>

        <div class="card" style="padding:12px;">
          <h3>Free Chlorine (ppm)</h3>
          <input id="mFc" type="number" step="0.01" min="0" placeholder="e.g., 2.0">
        </div>

        <div class="card" style="padding:12px;">
          <h3>Total Chlorine (ppm)</h3>
          <input id="mTc" type="number" step="0.01" min="0" placeholder="e.g., 2.5">
          <small class="muted">If TC &lt; FC, we’ll clamp to TC = FC.</small>
        </div>

        <div class="card" style="padding:12px;">
          <h3>Total Alkalinity (ppm)</h3>
          <input id="mAlk" type="number" step="1" min="0" placeholder="e.g., 100">
        </div>

        <div class="card" style="padding:12px;">
          <h3>Cyanuric Acid (ppm)</h3>
          <input id="mCya" type="number" step="1" min="0" placeholder="e.g., 40">
        </div>

        <div class="card" style="padding:12px;">
          <h3>Hardness (ppm)</h3>
          <input id="mHard" type="number" step="1" min="0" placeholder="e.g., 250">
        </div>

        <div class="card" style="padding:12px;">
          <h3>Bromine (ppm)</h3>
          <input id="mBr" type="number" step="0.1" min="0" placeholder="optional">
          <small class="muted">If blank, we’ll estimate from total chlorine.</small>
        </div>

        <div class="card" style="padding:12px;">
          <h3>Options</h3>
          <label class="muted" style="font-size:12px; display:block; margin-bottom:6px;">
            <input id="mCorrected" type="checkbox"> Mark as “chlorine corrected”
          </label>
          <small class="muted">Shown in Scanner tooltip footer for CC.</small>
        </div>
      </div>

      <div class="row row-wrap" style="margin-top:10px; gap:10px;">
        <button type="button" class="btn" id="mAdd">Add Datapoint</button>
        <button type="button" class="btn-ghost danger" id="mClearHistory">Clear All History</button>
        <div class="muted" id="mHint"></div>
      </div>

      <div style="margin-top:10px;">
        <h3>Recent manual/history points</h3>
        <div class="muted hint">You can delete individual entries from this device.</div>
        <div id="mList" class="card" style="padding:12px; overflow:auto;"></div>
      </div>

      <hr style="border:0; border-top:1px solid rgba(148,163,184,0.25); margin:14px 0;">

      <h3>4) What Judges Should Notice</h3>
      <ul>
        <li>Lighting changes RGB values — white balance reduces that error.</li>
        <li>Some pads have subtle steps — borderline readings display as a range (not a fake “exact” number).</li>
        <li>Repeatability: the same photo produces the same results (hash-based caching).</li>
      </ul>
    </section>
  </main>

  <script type="module">
    const CAL_KEY = "pt_calibration_v1";
    const HISTORY_KEY = "pt_history_v2";
    const MAX_HISTORY = 365;

    const els = {
      take: document.getElementById("calTake"),
      choose: document.getElementById("calChoose"),
      takeInput: document.getElementById("calTakeInput"),
      fileInput: document.getElementById("calFileInput"),
      reset: document.getElementById("calReset"),
      canvas: document.getElementById("calCanvas"),
      status: document.getElementById("calStatus"),
      wbTag: document.getElementById("wbTag"),
      offPh: document.getElementById("offPh"),
      offAlk: document.getElementById("offAlk"),
      offCya: document.getElementById("offCya"),
      offHard: document.getElementById("offHard"),
      save: document.getElementById("saveCal"),
      savedHint: document.getElementById("calSavedHint"),

      // Manual history UI
      mTime: document.getElementById("mTime"),
      mGallons: document.getElementById("mGallons"),
      mPh: document.getElementById("mPh"),
      mFc: document.getElementById("mFc"),
      mTc: document.getElementById("mTc"),
      mAlk: document.getElementById("mAlk"),
      mCya: document.getElementById("mCya"),
      mHard: document.getElementById("mHard"),
      mBr: document.getElementById("mBr"),
      mCorrected: document.getElementById("mCorrected"),
      mAdd: document.getElementById("mAdd"),
      mClearHistory: document.getElementById("mClearHistory"),
      mHint: document.getElementById("mHint"),
      mList: document.getElementById("mList"),
    };

    function setStatus(msg) { els.status.textContent = msg || ""; }
    function setHint(msg) { if (els.mHint) els.mHint.textContent = msg || ""; }

    function loadJson(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;
        return JSON.parse(raw);
      } catch {
        return fallback;
      }
    }

    function saveJson(key, val) {
      try { localStorage.setItem(key, JSON.stringify(val)); } catch {}
    }

    function loadCal() {
      return loadJson(CAL_KEY, null);
    }

    function saveCalObj(obj) {
      saveJson(CAL_KEY, obj);
    }

    function resetCal() {
      try { localStorage.removeItem(CAL_KEY); } catch {}
    }

    function loadHistory() {
      return loadJson(HISTORY_KEY, []);
    }

    function saveHistory(arr) {
      saveJson(HISTORY_KEY, arr);
    }

    function safeNum(v) {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function clampTcFc(tc, fc) {
      if (tc == null && fc == null) return { tc: null, fc: null, corrected: false };
      const _fc = fc == null ? 0 : Math.max(0, fc);
      let _tc = tc == null ? _fc : Math.max(0, tc);
      let corrected = false;
      if (_tc < _fc) { _tc = _fc; corrected = true; }
      return { tc: _tc, fc: _fc, corrected };
    }

    function inferBromine(br, tc) {
      const b = safeNum(br);
      if (b != null) return Math.max(0, Number(b.toFixed(1)));
      const t = safeNum(tc);
      if (t == null) return 0;
      return Math.max(0, Number((t * 2.25).toFixed(1)));
    }

    function parseWhen(datetimeLocalValue) {
      if (!datetimeLocalValue) return Date.now();
      const t = new Date(datetimeLocalValue).getTime();
      return Number.isFinite(t) ? t : Date.now();
    }

    function formatWhen(t) {
      try {
        return new Date(t).toLocaleString(undefined, {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit"
        });
      } catch {
        return String(t);
      }
    }

    function addHistoryPoint(point) {
      const history = loadHistory();

      history.push(point);
      history.sort((a, b) => (a.t || 0) - (b.t || 0));

      if (history.length > MAX_HISTORY) history.splice(0, history.length - MAX_HISTORY);
      saveHistory(history);

      renderHistoryList();
      setHint("Added. Go back to Scanner to see charts update.");
    }

    function deleteHistoryPointByTime(t) {
      const history = loadHistory();
      const next = history.filter(h => Number(h.t) !== Number(t));
      saveHistory(next);
      renderHistoryList();
    }

    function clearHistory() {
      try { localStorage.removeItem(HISTORY_KEY); } catch {}
      renderHistoryList();
      setHint("History cleared on this device.");
    }

    function renderHistoryList() {
      const history = loadHistory();
      const wrap = els.mList;
      if (!wrap) return;

      if (!history.length) {
        wrap.innerHTML = `<div class="muted">No saved history points on this device.</div>`;
        return;
      }

      const recent = history.slice(-25).reverse();

      wrap.innerHTML = `
        <table style="width:100%; border-collapse:collapse; font-size:13px;">
          <thead>
            <tr style="text-align:left; border-bottom:1px solid rgba(148,163,184,0.25);">
              <th style="padding:8px 6px;">When</th>
              <th style="padding:8px 6px;">pH</th>
              <th style="padding:8px 6px;">FC</th>
              <th style="padding:8px 6px;">TC</th>
              <th style="padding:8px 6px;">Alk</th>
              <th style="padding:8px 6px;">CYA</th>
              <th style="padding:8px 6px;">Action</th>
            </tr>
          </thead>
          <tbody>
            ${recent.map(h => `
              <tr style="border-bottom:1px solid rgba(148,163,184,0.18);">
                <td style="padding:7px 6px; white-space:nowrap;">${formatWhen(h.t)}</td>
                <td style="padding:7px 6px;">${h.ph ?? "–"}</td>
                <td style="padding:7px 6px;">${h.freeCl ?? "–"}</td>
                <td style="padding:7px 6px;">${h.totalCl ?? "–"}</td>
                <td style="padding:7px 6px;">${h.alk ?? "–"}</td>
                <td style="padding:7px 6px;">${h.cya ?? "–"}</td>
                <td style="padding:7px 6px;">
                  <button type="button" class="btn-ghost danger" data-del="${Number(h.t)}" style="padding:6px 10px;">Delete</button>
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
        <div class="muted" style="margin-top:8px;">Showing last ${recent.length} of ${history.length} points.</div>
      `;

      wrap.querySelectorAll("[data-del]").forEach(btn => {
        btn.addEventListener("click", () => deleteHistoryPointByTime(btn.getAttribute("data-del")));
      });
    }

    // Load existing calibration
    const existing = loadCal();
    if (existing?.offsets) {
      els.offPh.value = existing.offsets.ph ?? 0;
      els.offAlk.value = existing.offsets.alk ?? 0;
      els.offCya.value = existing.offsets.cya ?? 0;
      els.offHard.value = existing.offsets.hardness ?? 0;
    }
    if (existing?.whiteBalance) {
      const wb = existing.whiteBalance;
      els.wbTag.textContent = `WB: r=${wb.r.toFixed(3)} g=${wb.g.toFixed(3)} b=${wb.b.toFixed(3)}`;
    }

    async function loadFileToImage(file) {
      let bmp = null;
      try { bmp = await createImageBitmap(file, { imageOrientation: "from-image" }); }
      catch { bmp = await createImageBitmap(file); }

      const tmp = document.createElement("canvas");
      tmp.width = bmp.width;
      tmp.height = bmp.height;
      tmp.getContext("2d").drawImage(bmp, 0, 0);

      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = tmp.toDataURL("image/jpeg", 0.95);
      });
    }

    function drawImageFit(img) {
      const c = els.canvas;
      const maxW = 900;
      const scale = Math.min(1, maxW / (img.naturalWidth || img.width));
      c.width = Math.round((img.naturalWidth || img.width) * scale);
      c.height = Math.round((img.naturalHeight || img.height) * scale);
      const ctx2 = c.getContext("2d", { willReadFrequently: true });
      ctx2.drawImage(img, 0, 0, c.width, c.height);
      return ctx2;
    }

    let ctx = null;

    async function handleFile(file) {
      setStatus("Loading photo…");
      const img = await loadFileToImage(file);
      ctx = drawImageFit(img);
      setStatus("Tap a white/gray strip-body area to set white balance.");
    }

    els.take.addEventListener("click", () => els.takeInput.click());
    els.choose.addEventListener("click", () => els.fileInput.click());

    els.takeInput.addEventListener("change", async (e) => {
      const f = e.target.files?.[0]; if (!f) return;
      await handleFile(f); e.target.value = "";
    });
    els.fileInput.addEventListener("change", async (e) => {
      const f = e.target.files?.[0]; if (!f) return;
      await handleFile(f); e.target.value = "";
    });

    els.canvas.addEventListener("click", (ev) => {
      if (!ctx) return;

      const rect = els.canvas.getBoundingClientRect();
      const x = Math.round((ev.clientX - rect.left) * (els.canvas.width / rect.width));
      const y = Math.round((ev.clientY - rect.top) * (els.canvas.height / rect.height));

      const d = ctx.getImageData(x, y, 1, 1).data;
      const avg = (d[0] + d[1] + d[2]) / 3 || 1;
      const wb = { r: d[0] / avg, g: d[1] / avg, b: d[2] / avg };

      const cur = loadCal() || {};
      cur.whiteBalance = wb;
      cur.updatedAt = Date.now();
      saveCalObj(cur);

      els.wbTag.textContent = `WB: r=${wb.r.toFixed(3)} g=${wb.g.toFixed(3)} b=${wb.b.toFixed(3)}`;
      setStatus("White balance saved. Adjust offsets if needed, then click Save Calibration.");
    });

    els.save.addEventListener("click", () => {
      const cur = loadCal() || {};
      cur.offsets = {
        ph: Number(els.offPh.value || 0),
        alk: Number(els.offAlk.value || 0),
        cya: Number(els.offCya.value || 0),
        hardness: Number(els.offHard.value || 0)
      };
      cur.updatedAt = Date.now();
      saveCalObj(cur);
      els.savedHint.textContent = "Saved to this device. Go back to Scanner and scan again.";
      setStatus("Calibration saved.");
    });

    els.reset.addEventListener("click", () => {
      resetCal();
      els.wbTag.textContent = "WB: not set";
      els.offPh.value = 0; els.offAlk.value = 0; els.offCya.value = 0; els.offHard.value = 0;
      els.savedHint.textContent = "Calibration cleared.";
      setStatus("Calibration reset.");
    });

    // Manual history handlers
    els.mAdd?.addEventListener("click", () => {
      setHint("");

      const t = parseWhen(els.mTime?.value);
      const gallons = safeNum(els.mGallons?.value);

      const ph = safeNum(els.mPh?.value);
      const alk = safeNum(els.mAlk?.value);
      const cya = safeNum(els.mCya?.value);

      const fcIn = safeNum(els.mFc?.value);
      const tcIn = safeNum(els.mTc?.value);
      const { fc, tc, corrected } = clampTcFc(tcIn, fcIn);

      // Require minimum needed for graphs
      if (ph == null || alk == null || cya == null || fc == null || tc == null) {
        setHint("Please fill at least pH, FC, TC, Alk, and CYA.");
        return;
      }

      const hardness = safeNum(els.mHard?.value);
      const bromine = inferBromine(els.mBr?.value, tc);

      const point = {
        t,
        gallons: gallons != null ? Math.round(Math.max(0, gallons)) : null,
        ph: Number(ph.toFixed(2)),
        freeCl: Number(fc.toFixed(2)),
        totalCl: Number(tc.toFixed(2)),
        bromine: Number(bromine.toFixed(1)),
        hardness: hardness != null ? Math.round(Math.max(0, hardness)) : 0,
        alk: Math.round(Math.max(0, alk)),
        cya: Math.round(Math.max(0, cya)),
        chlorineCorrected: Boolean(els.mCorrected?.checked) || corrected
      };

      addHistoryPoint(point);

      // Keep date (often adding a series), clear values
      [els.mPh, els.mFc, els.mTc, els.mAlk, els.mCya, els.mHard, els.mBr].forEach(el => { if (el) el.value = ""; });
      if (els.mCorrected) els.mCorrected.checked = false;
    });

    els.mClearHistory?.addEventListener("click", () => {
      clearHistory();
    });

    renderHistoryList();
    setStatus("Ready. Load an unused strip photo to begin calibration.");
  </script>
</body>
</html>
